# JavaScript笔记
## JavaScript基本概念
1. JavaScript是一门用来与网页交互的脚本语言，浏览器对其有不同程度的支持[(查询)](https://caniuse.com/)
    - ECMAScipt：由ECMA-262定义并提供核心功能
    - 文档对象模型（DOM）：提供与网页内容交互的方法和接口
    - 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口
2. JavaScript可通过<script>元素插入到HTML页面中，也可以引入外部js代码
    - 引入外部js代码需要将src熟悉设置为JS文件的URL（可以和网页同一服务器，也可以不同的域）
    - <script>代码会在网页中按顺序被执行，<script>内的代码也会顺序执行（defer和async属性除外）
    - 顺序执行页面会在执行<script>内容时阻塞，一般吧<script>标签放主内容之后</body>标签之前
    - defer属性可把脚本推迟到文档渲染完毕后执行（推迟脚本原则上按照它们被列出的次序执行）
    - async属性表示脚本不需要等待其它脚本，同时不阻塞文档渲染，但不能保证在页面中出现的次序
3. ECMAScript的基本元素和特性（需要示例）
    - 基本数据类型：Undefined、Null、Boolean、Number、String、Symbol
    - 只有Number一种数值数据类型（不区分整数和浮点型）
    - 严格模式中对容易出错的部分施加了限制
    - ECMAScript提供类C语言的基本操作符和流程控制语句
    - 函数不需要指定返回值，不指定返回值的函数返回undefined
----
## 变量、作用域、内存
### 原始值和引用值
  - 区别：原始值就是六种数据类型的的简单数据，按值访问，保存到栈；引用值是多个值构成的对象（地址值），按引用访问，保存到堆
  - 动态属性：引用值可以随时添加、修改和删除其属性和方法；原始值不能有属性
  - 复制值：通过变量把原始值赋值到另一个变量时，原始值复制到新变量的位置（互不干扰）；引用值赋值实则是复制指针指向同一个对象（共享）
  - 传递参数：所有函数的参数都是按值传递，值被复制到局部变量（arguments对象槽位,与变量赋值类似）；原始值不会改变，引用值会被共享
  ```javascript
  function setName(obj){
    obj.name = "Sancho"
    obj = new Object()//重写
    obj.name = "Greg"
  }
  
  let person = new Object()
  setName(person)
  console.log(person.name)//"Sancho"
  ```
  - typeof操作符适合判断原始类型（String、Number、Boolean、Undefined）；判断null时返回object；
  - instanceof操作符判断对象类型（涉及对象原型链）；任何引用值和Object构造函数都会返回true，原始值则会返回false。`[1,2,3] instanceof Array//true`
### 执行上下文（作用域）
  - 每个变量或函数都有上下文；变量或函数的上下文决定了它们可以访问哪些数据、行为和生命周期；
  - 执行上下文分全局上下文、函数上下文、块级上下文
  - 代码执行流每进入一个新上下文都会创建一个作用域链，用于搜索变量和函数
  - 函数或块的局部上下文不仅可以访问自己作用域内和父级的变量
  - 全局上下文只能访问全局上下文中的变量和函数
  - 变量的执行上下文用于确定什么时候释放内存
### 垃圾回收
  - 离开作用域的值被自动标记为可回收
  - 主流的垃圾回收算法是标记清理（不用的值标记之后清理内存）
  - 少用的是引用计数策略，记录值被引用多少次，荣一直在循环引用时出现问题
  - 解除变量引用（赋值null）可以消除循环引用，帮助垃圾回收
----
## 基本引用类型
### 内置基本对象
  - 内置的引用类型可创建特定类型对象，与其他面向对象编程语言类似但实现不同
  - Date类型提供日期和时间的信息（包括日期、时间相关计算）
  - RegExp类型是正则表达式接口，提供基础和部分高级正则表达式功能
### 原始值包装类型
  - JS中函数是Function类型的实例（函数也是对象，所以函数有方法）
  - 原始值有包装类存在，原始值可以被当成对象使用（Boolean、Number、String）
  - 每种包装类型都映射到同名原始类型
  - 以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应数据
  - 涉及原始值的语句执行完毕后，包装对象就会被销毁
### 单例内置对象
  - 代码执行时全局上下文有Global和Math对象，Global一般无法直接访问（实现为window），所有全局变量和函数都是Global对象的属性；Math对象包含辅助完成复杂计算的属性和方法
----
## 集合引用类型（与上重合）
### 内置集合引用对象
  - Object类型是基础类型，所有引用类型都继承了它的基本行为
### 数组、定型数组
  - Array类型表示一组有序的值，并提供操作和转换值的能力
  - 定型数组包含一套不同的引用类型，用于管理数值在内存中的类型
### Map、WeakMap、set、WeakSet
  - Map、WeakMap、Set、WeakSet是ECMAScript新增的引用类型，为组织应用程序数据和简化内存管理提供了新能力
----
## 迭代器、生成器
### 迭代
  - 迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现Iterable接口的对象都有一个Symol.iterator属性，这个属性引用默认迭代器。默认迭代器就像迭代器工厂，也就是一个函数，调用之后会产生一个实现Iterator接口的对象
### 迭代器模式
  - 迭代器需要连续调用next()方法才能连续取得值（for-of循环也可以），这个方法返回一个IteratorObject。这个对象包含一个done属性和一个value属性。
    - done属性是一个布尔值，表示是否还有更多值访问
    - value属性包含迭代器返回的当前值
### 生成器
  - 生成器是一种特殊的函数，调用之后会返回一个生成器对象。生成器对象实现了Iterable接口，因此可用在任何消费可迭代对象的地方。生成器支持yield关键字，能够暂停执行生成器函数，还可通过next()方法接收输入和产生输出，加上星号之后可以将跟在它后面的可迭代对象序列化一连串值
----
## 对象、类、面向对象编程
### 自定义对象
  - 工厂模式：简单函数，可创建对象，为其添加属性和方法，返回这个对象
  - 构造函数模式：可自定义引用类型；缺点是成员无法重用（包括函数）
  - 原型模式：成员可以共享；
  - 组合构造函数和原型模式：通过构造函数定义实例属性，通过原型定义共享的属性和方法
  - 盗用构造函数模式（传统继承）：在子类构造函数中调用父类构造函数实现每个实例继承的属性都是私有，只能通过构造函数模式定义（子类不能访问父类原型上的方法）
  - 组合继承模式（推荐）：通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性
  - 原型式继承模式：无须明确定义构造函数而实现继承，本质上是对给定对象执行浅复制（操作的结果可以在之后再次增强）
  - 寄生式模式：基于一个对象创建一个新对象，然后再增强这个新对象，然后返回新对象；
  - 寄生组合继承模式（最有效）：用于避免重复调用父类构造函数导致的浪费
### 对象创建过程（原型链）、继承
 - JS的继承主要通过原型链实现，原型链涉及吧构造函数的原型赋值为另一个类型的实例（子类可访问父类所有属性和方法）；所有继承的属性和方法都会在对象实例间共享（实例不能私有）
### 类
  - ES6新增类基于语法糖，方便定义向后兼容的类，可以继承内置类型和自定义类型；有效使用对象实例、对象原型和对象类
## 代理、反射
### 代理
  - 代理可以定义包含捕获器的处理程序对象，可以蓝爵大部分基本操作和方法，以修改基本操作的行为（遵从捕获器不变式）
### 代码捕获器与反射方法
  - 反射API封装了与捕获器拦截操作相对应的方法
### 代理模式
  - 代理可以创建出各种编码模式（如跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定、可观察对象等）
----
## 函数
### 函数表达式、函数声明、箭头函数
  - 函数声明需要函数名称，函数表达式不需要，没有名称叫匿名函数
  - 箭头函数语法
### 默认参数及扩展操作符
  - arguments对象及ES6新增扩展操作符可以实现函数定义和调用的完全动态化
  - 函数内部暴露的对象和引用
  - 尾调用函数优化栈空间
### 使用函数实现递归
  - 闭包在函数返回之后，其作用域会一直保存在内存中，直到闭包被销毁
  - 立即调用函数在执行后不留下对函数的引用；立即调用函数表达式如果不在包含作用域中将返回值赋给一个变量，则其包含的所有变量都会被销毁
### 使用闭包实现私有变量
  - 可使用闭包实现公共方法，访问位于作用于中定义变量
  - 可以访问私有变量的公共方法（特权方法），特权方法可以使用构造函数或原型模式通过自定义类型中实现，也可以使用模块模式或者模块增强模式在单例对象上实现
## 期约、异步
### 异步
  - async/await
### 期约
  - 期约的主要功能是为异步代码提供清晰的抽象，可以用期约表示异步代码执行的代码块，也可以用期约表示异步计算的值；异步代码串行，可塑性强，可序列化、连锁使用、复合、拓展和重组
### 异步函数
  - 异步函数是将期约应用于JS函数的结果；异步函数可以暂停执行而不阻塞主线程；可方便编写基于期约的代码和组织串行或平行执行的异步代码
